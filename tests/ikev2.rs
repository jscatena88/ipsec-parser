extern crate ipsec_parser;
extern crate nom;

mod ikev2 {
    use ipsec_parser::*;

    #[rustfmt::skip]
static IKEV2_MSG: &'static [u8] = &[
  0x00, 0x00, 0x00, 0x00, 0xbc, 0xa1, 0x93, 0x7a, 0x7c, 0x2f, 0xf5, 0xb9, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x21, 0x20, 0x22, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2c,
  0x22, 0x00, 0x00, 0xa4, 0x02, 0x00, 0x00, 0x24, 0x01, 0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x0c,
  0x01, 0x00, 0x00, 0x14, 0x80, 0x0e, 0x00, 0x80, 0x03, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x05,
  0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x1c, 0x02, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x03,
  0x03, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x14, 0x80, 0x0e, 0x00, 0x80, 0x03, 0x00, 0x00, 0x08,
  0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x13, 0x02, 0x00, 0x00, 0x2c,
  0x03, 0x01, 0x00, 0x04, 0x03, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x0d, 0x80, 0x0e, 0x00, 0x80,
  0x03, 0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x05,
  0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x2c, 0x04, 0x01, 0x00, 0x04,
  0x03, 0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x0d, 0x80, 0x0e, 0x00, 0x80, 0x03, 0x00, 0x00, 0x08,
  0x03, 0x00, 0x00, 0x0c, 0x03, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x08,
  0x04, 0x00, 0x00, 0x13, 0x28, 0x00, 0x00, 0x48, 0x00, 0x1c, 0x00, 0x00, 0x4d, 0x23, 0xb8, 0xf2,
  0x2c, 0x03, 0xae, 0x3a, 0xb4, 0x0a, 0xf9, 0xfa, 0x76, 0xc2, 0x3c, 0x7b, 0xa6, 0xc5, 0x69, 0x81,
  0xe1, 0x3c, 0x32, 0xfb, 0xc3, 0x69, 0x54, 0xc8, 0x7a, 0x96, 0xcb, 0xfa, 0x34, 0x63, 0x7c, 0x6f,
  0x31, 0xb6, 0x50, 0xce, 0x5d, 0x87, 0x17, 0x00, 0x5c, 0xe7, 0x93, 0xc2, 0xee, 0xaf, 0xf1, 0xc5,
  0x66, 0x28, 0x08, 0x11, 0xd9, 0x42, 0xd1, 0xb8, 0xe8, 0x02, 0x68, 0xbb, 0x00, 0x00, 0x00, 0x24,
  0x99, 0xe2, 0xa3, 0x73, 0xcc, 0x44, 0xad, 0x10, 0xfb, 0x78, 0xdd, 0xa2, 0x52, 0x06, 0xa4, 0xa9,
  0xb7, 0x55, 0x8e, 0x0d, 0x82, 0x69, 0x79, 0x9c, 0x68, 0x00, 0x36, 0x2c, 0x46, 0xa0, 0xbf, 0x7b
];

    #[test]
    fn test_ipsec_ike_sa() {
        let bytes = &IKEV2_MSG[4..32];
        let ike_sa = &IKEV2_MSG[32..];
        let expected = IkeV2Header {
            init_spi: 0xbca1937a7c2ff5b9,
            resp_spi: 0x0,
            next_payload: IkePayloadType::SecurityAssociation,
            maj_ver: 2,
            min_ver: 0,
            exch_type: IkeExchangeType::IKE_SA_INIT,
            flags: 0x8,
            msg_id: 0,
            length: 300,
        };
        let (_, res) = parse_ikev2_header(&bytes).expect("failed to parse header");
        // println!("{:?}",res);
        assert_eq!(res, expected);

        let (_, hdr) = parse_ikev2_payload_generic(&ike_sa).expect("failed to parse payload");
        // println!("{:?}",res_sa);
        let (rem, sa) = parse_ikev2_payload_sa(hdr.payload, 0).unwrap();
        assert_eq!(rem.len(), 0);
        match sa {
            IkeV2PayloadContent::SA(ref sa_list) => {
                assert_eq!(sa_list.len(), 4);
                // for sa in sa_list.iter() {
                //     println!("sa: {:?}", sa);
                // }
                sa_list
                    .iter()
                    .zip(&[3, 3, 4, 4])
                    .for_each(|(a, b)| assert_eq!(a.num_transforms, *b));
                sa_list
                    .iter()
                    .for_each(|a| assert_eq!(a.transforms.len(), a.num_transforms as usize));
            }
            _ => assert!(false),
        }
    }

    static IKEV2_INIT_REQ: &'static [u8] = include_bytes!("../assets/ike-sa-init-req.bin");

    #[test]
    fn test_ipsec_ike_message() {
        let bytes = IKEV2_INIT_REQ;
        let expected_header = IkeV2Header {
            init_spi: 0x54c184961bc3fd77,
            resp_spi: 0x0,
            next_payload: IkePayloadType::SecurityAssociation,
            maj_ver: 2,
            min_ver: 0,
            exch_type: IkeExchangeType::IKE_SA_INIT,
            flags: 0x8,
            msg_id: 0,
            length: 256,
        };
        let (rem, (hdr, res_list)) = parse_ikev2_message(&bytes).expect("failed to parse header");
        let list = res_list.expect("failed to parse payload");
        assert_eq!(rem.len(), 0);
        assert_eq!(hdr, expected_header);
        assert_eq!(list.len(), 4);
        for (a, b) in list.iter().zip(&[33, 34, 40, 0]) {
            assert_eq!(a.hdr.next_payload_type, IkePayloadType(*b));
        }
    }

} // mod ikev2
